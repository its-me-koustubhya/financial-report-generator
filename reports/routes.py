from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from database.connection import get_db
from database.models import User, Report
from auth.dependencies import get_current_user
from pydantic import BaseModel
from datetime import datetime
from graph.workflow import create_report_workflow
from config import get_settings

router = APIRouter(prefix="/reports", tags=["Reports"])

class ReportRequest(BaseModel):
    company_name: str
    focus: str | None = None

class ReportResponse(BaseModel):
    id: int
    company_name: str
    focus: str | None
    report_content: str
    status: str
    created_at: datetime
    
    class Config:
        from_attributes = True

@router.post("/generate", response_model=ReportResponse)
async def generate_report(
    request: ReportRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Generate a financial analysis report for a company.
    
    Requires:
    - Authentication (Bearer token)
    - User must have configured Groq and Tavily API keys
    
    - **company_name**: Name of the company to analyze
    - **focus**: Optional specific focus area for the report
    """
    # Check if user has API keys configured
    if not current_user.groq_api_key or not current_user.tavily_api_key:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Please configure your API keys first using PUT /auth/api-keys"
        )
    
    # Create a pending report entry
    new_report = Report(
        user_id=current_user.id,
        company_name=request.company_name,
        focus=request.focus,
        report_content="",
        status="pending"
    )
    db.add(new_report)
    db.commit()
    db.refresh(new_report)
    
    try:
        # Generate report
        workflow = create_report_workflow(
            groq_api_key=current_user.groq_api_key,
            tavily_api_key=current_user.tavily_api_key
        )

        result = workflow.invoke({
            "company": request.company_name,
            "focus": request.focus or "",
        })
        
        final_report = result.get("final_report", "")
        
        if not final_report:
            raise Exception("Workflow completed but no report was produced")
        
        # Update report with content
        new_report.report_content = final_report
        new_report.status = "success"
        db.commit()
        db.refresh(new_report)
        
        return new_report
        
    except Exception as e:
        # Update report with error status
        new_report.status = "failed"
        new_report.report_content = f"Error: {str(e)}"
        db.commit()
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating report: {str(e)}"
        )

@router.get("/", response_model=List[ReportResponse])
def get_my_reports(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 10
):
    """
    Get all reports generated by the current user.
    
    - **skip**: Number of reports to skip (for pagination)
    - **limit**: Maximum number of reports to return (default 10, max 50)
    """
    if limit > 50:
        limit = 50
    
    reports = db.query(Report)\
        .filter(Report.user_id == current_user.id)\
        .order_by(Report.created_at.desc())\
        .offset(skip)\
        .limit(limit)\
        .all()
    
    return reports

@router.get("/{report_id}", response_model=ReportResponse)
def get_report(
    report_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get a specific report by ID.
    
    Can only access your own reports.
    """
    report = db.query(Report)\
        .filter(Report.id == report_id, Report.user_id == current_user.id)\
        .first()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    return report

@router.delete("/{report_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_report(
    report_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Delete a report by ID.
    
    Can only delete your own reports.
    """
    report = db.query(Report)\
        .filter(Report.id == report_id, Report.user_id == current_user.id)\
        .first()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    db.delete(report)
    db.commit()
    
    return None